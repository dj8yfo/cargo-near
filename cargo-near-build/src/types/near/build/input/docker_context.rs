use crate::ManifestPath;
use colored::Colorize;

impl super::Opts {
    pub fn contract_path(&self) -> eyre::Result<camino::Utf8PathBuf> {
        let contract_path: camino::Utf8PathBuf = if let Some(manifest_path) = &self.manifest_path {
            let manifest_path = ManifestPath::try_from(manifest_path.clone())?;
            manifest_path.directory()?.to_path_buf()
        } else {
            camino::Utf8PathBuf::from_path_buf(std::env::current_dir()?)
                .map_err(|err| eyre::eyre!("Failed to convert path {}", err.to_string_lossy()))?
        };
        Ok(contract_path)
    }

    const BUILD_COMMAND_CLI_CONFIG_ERR: &'static str =  "cannot be used, when `container_build_command` is configured from `[package.metadata.near.reproducible_build]` in Cargo.toml";

    pub fn get_cli_build_command_in_docker(
        &self,
        manifest_command: Option<Vec<String>>,
    ) -> eyre::Result<String> {
        if let Some(cargo_cmd) = manifest_command {
            // NOTE: `--no-locked` is allowed for docker builds
            // if self.no_locked {
            //     no-op
            // }
            if self.no_release {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--no-release",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            if self.no_abi {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--no-abi",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            if self.no_embed_abi {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--no-embed-abi",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            if self.no_doc {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--no-doc",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            if self.features.is_some() {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--features",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            if self.no_default_features {
                return Err(eyre::eyre!(format!(
                    "`{}` {}",
                    "--no-default-features",
                    Self::BUILD_COMMAND_CLI_CONFIG_ERR
                )));
            }
            return Ok(cargo_cmd.join(" "));
        }
        println!(
            "{}",
            "configuring `container_build_command` from cli args, passed to current command".cyan()
        );
        let mut cargo_args = vec![];
        // NOTE: not passing through `no_locked` to cmd in container,
        // an invisible Cargo.lock was generated by implicit `cargo metadata` anyway
        // if self.no_locked {
        //     no-op
        // }
        if self.no_release {
            cargo_args.push("--no-release");
        }
        if self.no_abi {
            cargo_args.push("--no-abi");
        }
        if self.no_embed_abi {
            cargo_args.push("--no-embed-abi");
        }
        if self.no_doc {
            cargo_args.push("--no-doc");
        }
        if let Some(ref features) = self.features {
            cargo_args.extend(&["--features", features]);
        }
        if self.no_default_features {
            cargo_args.push("--no-default-features");
        }

        let color;
        if let Some(ref color_arg) = self.color {
            color = color_arg.to_string();
            cargo_args.extend(&["--color", &color]);
        }
        // TODO: use cli_command_prefix
        //         let cargo_args = self.cli_description.cli_command_prefix.clone();
        let mut cargo_cmd_list = vec!["cargo", "near", "build"];
        cargo_cmd_list.extend(&cargo_args);
        let cargo_cmd = cargo_cmd_list.join(" ");
        Ok(cargo_cmd)
    }
}
